import 'dart:ffi' as ffi;

import 'package:clawclip/clawclip.dart' as cc;
import 'package:clawclip/glfw.dart';
import 'package:clawclip/opengl.dart';
import 'package:ffi/ffi.dart' as ffi;
import 'package:image/image.dart';
import 'package:logging/logging.dart';

import 'baked_assets.g.dart' as assets;
import 'context.dart';
import 'core/cursors.dart';
import 'errors.dart';
import 'native/arena.dart';
import 'resources.dart';

typedef SurfaceResizeEvent = ({int newWidth, int newHeight});

abstract interface class Surface {
  int get width;
  int get height;

  Stream<SurfaceResizeEvent> get onResize;

  CursorStyle get cursorStyle;
  set cursorStyle(CursorStyle value);

  Future<RenderContext> createRenderContext(BraidResources resources);

  void beginDrawing();
  void endDrawing();

  void dispose();

  cc.GlCall<Image> capture();
}

class WindowSurface implements Surface {
  final cc.Window window;
  final CursorController _cursorController;

  WindowSurface.ofWindow({required this.window}) : _cursorController = CursorController.ofWindow(window);

  factory WindowSurface.createWindow({
    required String title,
    int width = 1000,
    int height = 750,
    List<cc.WindowFlag> flags = const [],
    Logger? logger,
  }) {
    if (cc.clawlipLoggingConfig == null) {
      cc.clawclipSetupLoggingInIsolate(
        baseLogger: logger,
        glConfig: const .new(messageFilter: _glLoggingFilter),
        glfwConfig: .noStacktraces,
      );
    }

    if (glfwInit() != glfwTrue) {
      final errorPointer = ffi.malloc<ffi.Pointer<ffi.Char>>();
      glfwGetError(errorPointer);

      final errorString = errorPointer.cast<ffi.Utf8>().toDartString();
      ffi.malloc.free(errorPointer);

      throw BraidInitializationException('GLFW initialization error: $errorString');
    }

    final window = cc.Window(width, height, title, flags: flags);
    window.setIcon(assets.braidIcon);

    window.activateContext();
    cc.Window.disableVsyncInContext();
    cc.Window.dropContext();

    return WindowSurface.ofWindow(window: window);
  }

  @override
  int get width => window.width;

  @override
  int get height => window.height;

  @override
  Stream<SurfaceResizeEvent> get onResize => window.onFramebufferResize;

  @override
  CursorStyle get cursorStyle => _cursorController.style;

  @override
  set cursorStyle(CursorStyle value) => _cursorController.style = value;

  @override
  Future<RenderContext> createRenderContext(BraidResources resources) async {
    final context = RenderContext(window);

    final shaderSetup = await Future.wait(
      [
        BraidShader(source: resources, name: 'blit', vert: 'blit', frag: 'blit'),
        BraidShader(source: resources, name: 'text', vert: 'text', frag: 'text'),
        BraidShader(source: resources, name: 'solid_fill', vert: 'pos', frag: 'solid_fill'),
        BraidShader(source: resources, name: 'colored_fill', vert: 'pos_color', frag: 'colored_fill'),
        BraidShader(source: resources, name: 'texture_fill', vert: 'pos_uv', frag: 'texture_fill'),
        BraidShader(source: resources, name: 'rounded_rect_solid', vert: 'pos', frag: 'rounded_rect_solid'),
        BraidShader(source: resources, name: 'rounded_rect_outline', vert: 'pos', frag: 'rounded_rect_outline'),
        BraidShader(source: resources, name: 'circle_solid', vert: 'pos', frag: 'circle_solid'),
        BraidShader(source: resources, name: 'circle_sector', vert: 'pos', frag: 'circle_sector'),
        BraidShader(source: resources, name: 'gradient_fill', vert: 'pos_uv', frag: 'gradient_fill'),
        BraidShader(source: resources, name: 'blur', vert: 'pos', frag: 'blur'),
      ].map(context.addShader).toList(),
    );

    window.activateContext();
    cc.GlCall.allOf(shaderSetup)();
    cc.Window.dropContext();

    return context;
  }

  @override
  void beginDrawing() {
    window.activateContext();

    gl.viewport(0, 0, window.width, window.height);

    gl.clearColor(0, 0, 0, 1);
    gl.clear(glColorBufferBit | glDepthBufferBit);
  }

  @override
  void endDrawing() {
    window.swapBuffers();
    cc.Window.pollEvents();
    // invoke it twice?? so that we don't miss some
    // glfw cursor move events on wayland
    cc.Window.pollEvents();
    cc.Window.dropContext();
  }

  @override
  void dispose() {
    window.dispose();
  }

  // ---

  @override
  cc.GlCall<Image> capture() => cc.GlCall(
    () => ffi.malloc.arena((arena) {
      final bufferSize = width * height * 4;

      final pixelBuffer = arena<ffi.Uint8>(bufferSize);
      gl.readPixels(0, 0, width, height, glRgba, glUnsignedByte, pixelBuffer.cast());

      final pixels = pixelBuffer.asTypedList(bufferSize);
      final image = Image.fromBytes(width: width, height: height, bytes: pixels.buffer, numChannels: 4);

      return flipVertical(image);
    }),
  );

  // ---

  // for now, filter out performance messages since those are excessively generated by the
  // nvidia drivers when they recompiles shaders due to the context making a thread hop,
  // which is something braid (unfortunately) causes somewhat frequently
  static bool _glLoggingFilter(cc.GlMessageType type, cc.GlSeverity severity) =>
      cc.GlLoggingConfig.severityLowAllTypesNoStacktraces.messageFilter(type, severity) && type != .performance;
}
